% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evppi.R, R/evppi.default.R
\name{evppi}
\alias{evppi}
\alias{evppi.default}
\alias{evppi.bcea}
\title{Expected Value of Perfect Partial Information (EVPPI) for Selected
Parameters}
\usage{
evppi(he, param_idx, input, N = NULL, plot = FALSE, residuals = TRUE, ...)

\method{evppi}{default}(he, ...)

\method{evppi}{bcea}(
  he,
  param_idx = NULL,
  input,
  N = NULL,
  plot = FALSE,
  residuals = TRUE,
  method = NULL,
  ...
)
}
\arguments{
\item{he}{A \code{bcea} object containing the results of the Bayesian
modelling and the economic evaluation.}

\item{param_idx}{A vector of parameters for which the EVPPI should be
calculated. This can be given as a string (or vector of strings) of names or
a numeric vector, corresponding to the column numbers of important
parameters.}

\item{input}{A matrix containing the simulations for all the parameters
monitored by the call to JAGS or BUGS. The matrix should have column names
matching the names of the parameters and the values in the vector parameter
should match at least one of those values.}

\item{N}{The number of PSA simulations used to calculate the EVPPI. The
default uses all the available samples.}

\item{plot}{A logical value indicating whether the triangular mesh for
SPDE-INLA should be plotted. Default set to \code{FALSE}.}

\item{residuals}{A logical value indicating whether the fitted values for
the SPDE-INLA method should be outputted. Default set to \code{TRUE}.}

\item{...}{Additional arguments. Details of the methods to compute the EVPPI and their additional arguments are:
\itemize{
\item For single-parameter:
\itemize{
\item Generalized additive model (GAM) (default).
\item The method of Strong & Oakley use \code{method} as string \code{so}.
The user \emph{needs} to also specify the number of "blocks" (e.g. \code{n.blocks=20}).
Note that the multi-parameter version for this method has been deprecated.
\item The method of Sadatsafavi \emph{et al.} where \code{method} takes as value a string of either \code{sad} or \code{sal}.
It is then possible to also specify the number of "separators" (e.g. \code{n.seps=3}).
If none is specified, the default value \code{n.seps=1} is used.
Note that the multi-parameter version for this method has been deprecated.
}
\item For multi-parameter:
\itemize{
\item INLA/SPDE (default).
\item Gaussian process regression with \code{method} of \code{gp}.
}
}}

\item{method}{Character string to select which method to use. The default methods are recommended.
However, it is possible (mainly for backward compatibility) to use different methods.}
}
\value{
An object of class \code{evppi}, containing the following components:
\itemize{
\item \strong{evppi}: The computed values of \code{evppi} for all values of the parameter of willingness to pay.
\item \strong{index}: A numerical vector with the indices of the parameters for which the EVPPI was calculated.
\item \strong{k}: A vector of values for the willingness to pay.
\item \strong{evi}: A vector of values for the overall EVPPI.
\item \strong{fitted.costs}: The fitted values for the costs.
\item \strong{fitted.effects}: The fitted values for the effects.
\item \strong{parameters}: A single string containing the names of the parameters for which the EVPPI was calculated (used for plotting).
\item \strong{time}: The computational time (in seconds).
\item \strong{fit.c}: The object produced by the model fit for the costs.
\item \strong{fit.e}: The object produced by the model fit for the effects.
\item \strong{formula}: The formula used to fit the model.
\item \strong{method}: A string indicating the method used to estimate the EVPPI.
}
}
\description{
Calculates the Expected Value of Perfect Partial Information (EVPPI) for
subsets of parameters. Uses GAM non-parametric regression for single
parameter EVPPI and the SPDE-INLA method for larger parameter subsets.
}
\details{
The single parameter EVPPI has been calculated using the non-parametric GAM
regression developed by Strong \emph{et al.} (2014). The multi-parameter EVPPI is
calculated using the SPDE-INLA regression method for Gaussian Process
regression developed by Heath \emph{et al.} (2015).

This function has been completely changed and restructured to make it possible
to change regression method.
The method argument can now be given as a list. The first element element in the
list is a vector giving the regression method for the effects. The second gives
the regression method for the costs. The \verb{method' argument can also be given as before which then uses the same regression method for all curves. All other }extra_args\verb{can be given as before.}int.ord\verb{can be updated using the list formulation above to give the interactions for each different curve. The formula argument for GAM can only be given once, either}te()\code{or}s() + s()`
as this is for computational reasons rather than to aid fit.
You can still plot the INLA mesh elements but not output the meshes.
}
\section{GAM regression}{

For multi-parameter, the user can select 3 possible methods. If
\code{method = "GAM"} (BCEA will accept also \code{"gam"}, \code{"G"} or
\code{"g"}), then the computations are based on GAM regression. The user can
also specify the formula for the regression. The default option is to use a
tensor product (e.g. if there are two main parameters, \code{p1} and
\code{p2}, this amounts to setting \code{formula = "te(p1,p2)"}, which
indicates that the two parameters interact). Alternatively, it is possible
to specify a model in which the parameters are independent using the
notation \code{formula = "s(p1) + s(p2)"}. This may lead to worse accuracy in
the estimates.
}

\section{Strong \emph{et al.} GP regression}{

This is used if \code{method="GP"} (BCEA will also accept the specification
\code{method="gp"}). In this case, the user can also specify the number of
PSA runs that should be used to estimate the hyperparameters of the model
(e.g. \code{n.sim=100}). This value is set by default to 500.
}

\section{INLA-related options}{

These are all rather technical and are described in detail in Baio \emph{et al.} (2017).
The optional parameter vector \code{int.ord} can take integer values (c(1,1) is
default) and will force the predictor to include interactions: if
\code{int.ord = c(k, h)}, then all k-way interactions will be used for the
effects and all h-way interactions will be used for the costs. Also, the
user can specify the feature of the mesh for the "spatial" part of the
model. The optional parameter \code{cutoff} (default 0.3) controls the
density of the points inside the mesh. Acceptable values are typically in
the interval (0.1, 0.5), with lower values implying more points (and thus
better approximation and greater computational time). The construction of the
boundaries for the mesh can be controlled by the optional inputs
\code{convex.inner} (default = -0.4) and \code{convex.outer} (default =
-0.7). These should be negative values and can be decreased (say to -0.7 and
-1, respectively) to increase the distance between the points and the outer
boundary, which also increases precision and computational time. The
optional argument\code{robust} can be set to TRUE, in which case INLA will
use a t prior distribution for the coefficients of the linear predictor.
Finally, the user can control the accuracy of the INLA grid-search for the
estimation of the hyperparameters. This is done by setting a value
\code{h.value} (default = 0.00005). Lower values imply a more refined search
(and hence better accuracy), at the expense of computational speed. The
method argument can also be given as a list allowing different regression
methods for the effects and costs, and the different incremental decisions.
The first list element should contain a vector of methods for the
incremental effects and the second for the costs, for example
\code{method = list(c("GAM"), c("INLA"))}. The \code{int.ord} argument can also
be given as a list to give different interaction levels for each regression
curve.

By default, when no method is specified by the user, \code{evppi} will
use GAM if the number of parameters is <5 and INLA otherwise.
}

\examples{
# See Baio G., Dawid A.P. (2011) for a detailed description of the 
# Bayesian model and economic problem

\dontrun{
# Load the post-processed results of the MCMC simulation model
# original JAGS output is can be downloaded from here
# https://gianluca.statistica.it/books/bcea/code/vaccine.RData

data(Vaccine, package = "BCEA")
treats <- c("Status quo", "Vaccination")

# Run the health economic evaluation using BCEA
m <- bcea(e.pts, c.pts, ref = 2, interventions = treats)

# Compute the EVPPI for a bunch of parameters
inp <- createInputs(vaccine_mat)

# explicitly use BCEA package namespace to avoid voi package conflict
EVPPI <- BCEA::evppi(m, c("beta.1." , "beta.2."), inp$mat)

plot(EVPPI)

# deprecated (single parameter) methods
EVPPI.so <- BCEA::evppi(m, c("beta.1.", "beta.2."), inp$mat, method = "so", n.blocks = 50)
EVPPI.sad <- BCEA::evppi(m, c("beta.1.", "beta.2."), inp$mat, method = "sad", n.seps = 1)

plot(EVPPI.so)
plot(EVPPI.sad)
 
# Compute the EVPPI using INLA/SPDE
if (require("INLA"))
  x_inla <- BCEA::evppi(he = m, 39:40, input = inp$mat)

# using GAM regression
x_gam <- BCEA::evppi(he = m, 39:40, input = inp$mat, method = "GAM")

# using Strong et al GP regression
x_gp <- BCEA::evppi(he = m, 39:40, input = inp$mat, method = "GP")

# plot results
if (require("INLA")) plot(x_inla)
points(x_inla$k, x_inla$evppi, type = "l", lwd = 2, lty = 2)
points(x_gam$k, x_gam$evppi, type = "l", col = "red")
points(x_gp$k, x_gp$evppi, type = "l", col = "blue")

if (require("INLA")) {
  plot(x_inla$k, x_inla$evppi, type = "l", lwd = 2, lty = 2)
  points(x_gam$k, x_gam$evppi, type = "l", col = "red")
  points(x_gp$k, x_gp$evppi, type = "l", col = "blue")
}

data(Smoking)
treats <- c("No intervention", "Self-help",
"Individual counselling", "Group counselling")
m <- bcea(eff, cost, ref = 4, interventions = treats, Kmax = 500)
inp <- createInputs(smoking_output)
EVPPI <- BCEA::evppi(m, c(2,3), inp$mat, h.value = 0.0000005)
plot(EVPPI)
}

}
\references{
\insertRef{Strong2014}{BCEA}

\insertRef{Sadatsafavi2013}{BCEA}

\insertRef{Baio2013}{BCEA}

\insertRef{Baio2017}{BCEA}

\insertRef{Heath2016}{BCEA}
}
\seealso{
\code{\link[=bcea]{bcea()}},
\code{\link[=plot.evppi]{plot.evppi()}}
}
\author{
Anna Heath, Gianluca Baio
}
